assign_values:
  assign:
    request: ${incoming.body}
    protocolVersion: 'V0.9.0'
    schema: ${incoming.body.ovon.schema}
    speakerId: "null"

controlEvent:
  call: http.post
  args:
    url: "[#DMAPPER_URL]:[#DMAPPER_PORT]/dmapper/controlEvent"
    body:
      req: ${request}
  result: eventTypeResponse
  next: assignEventType

assignEventType:
  assign:
    eventType: ${eventTypeResponse.response.body.data}

checkEvents:
  switch:
    - condition: ${eventType === 'invite'}
      next: createInviteMessage
    - condition: ${eventType === 'whisper'}
      next: convertOvonToByk
    - condition: ${eventType === 'utterance'}
      next: convertOvonToByk
    - condition: ${eventType === 'bye'}
      next: createByeMessage
  next: returnError

createByeMessage:
  call: http.post
  args:
    url: "[#DMAPPER_URL]:[#DMAPPER_PORT]/dmapper/bykMessageResponse"
    body:
      id: ${request.ovon.conversation.id}
      lastMessage: "Goodbye!"
  result: convertedResponse
  next: convertBykToOvon

createInviteMessage:
  call: http.post
  args:
    url: "[#DMAPPER_URL]:[#DMAPPER_PORT]/dmapper/bykMessageResponse"
    body:
      id: ${request.ovon.conversation.id}
      lastMessage: "Hello! How may i help you?"
  result: convertedResponse
  next: convertBykToOvon

convertOvonToByk:
  call: http.post
  args:
    url: "[#DMAPPER_URL]:[#DMAPPER_PORT]/dmapper/ovonToByk-${protocolVersion}"
    body:
      request: ${request}
      type: "message"
      eventType: ${eventType}
      protocolVersion: ${protocolVersion}
  result: bykRequest

checkNextStep:
  switch:
    - condition: ${eventType === 'whisper'}
      next: convertEmptyBykToOvon
    - condition: ${eventType === 'utterance'}
      next: assignSessionId

assignSessionId:
  assign:
    sessionId: ${bykRequest.response.body.data.message.chatId}

sendMessageToRasa:
  call: http.post
  args:
    url: "[#RASA_URL]:[#RASA_PORT]/conversations/${sessionId}/messages"
    body:
      text: ${bykRequest.response.body.data.message.content}
      sender: "user"
  result: rasaMessageResult

checkIfBook:
  switch:
    - condition: ${rasaMessageResult.response.body.latest_message.intent_ranking[0].name.includes('book')}
      next: getBookIntent
    - condition: ${rasaMessageResult.response.body.events.filter(event => event.event === 'slot').length > 0}
      next: getIntentMessageWithSlot
  next: getIntentMessage

getBookIntent:
  call: http.post
  args:
    url: "[#RASA_URL]:[#RASA_PORT]/conversations/${sessionId}/trigger_intent"
    body:
      name: ${rasaMessageResult.response.body.latest_message.intent_ranking[0].name}
  result: intentResponse

createBookResponse:
  call: http.post
  args:
    url: "[#DMAPPER_URL]:[#DMAPPER_PORT]/dmapper/bykMessageResponse"
    body:
      id: ${sessionId}
      lastMessage: ${rasaMessageResult.response.body.latest_message.text}
  result: convertedResponse
  next: convertBookBykToOvon

getIntentMessage:
  call: http.post
  args:
    url: "[#RASA_URL]:[#RASA_PORT]/conversations/${sessionId}/trigger_intent"
    body:
      name: ${rasaMessageResult.response.body.latest_message.intent_ranking[0].name}
  result: intentResponse
  next: createResponse

getIntentMessageWithSlot:
  call: http.post
  args:
    url: "[#RASA_URL]:[#RASA_PORT]/conversations/${sessionId}/trigger_intent"
    body:
      name: ${rasaMessageResult.response.body.latest_message.intent_ranking[0].name}
      slots:
        name: ${rasaMessageResult.response.body.events.filter(event => event.event === 'slot')[0].name}
        value: ${rasaMessageResult.response.body.events.filter(event => event.event === 'slot')[0].value}
  result: intentResponse
  next: createResponse

convertBookBykToOvon:
  call: http.post
  args:
    url: "[#DMAPPER_URL]:[#DMAPPER_PORT]/dmapper/bykToOvon-${protocolVersion}"
    body:
      bykResponse: ${convertedResponse.response.body.data}
      eventType: 'utterance'
      schemaVersion: ${schema.version}
      schemaUrl: ${schema.url}
      sender: ${request.ovon.sender.from}
      speakerId: ${speakerId}
  result: ovonResult

connectSmartLibrary:
  call: http.post
  args:
    url: "[#DMAPPER_URL]:[#DMAPPER_PORT]/request/library"
    body:
      ovon: ${ovonResult.response.body.data.ovon}
    headers:
      content-type: "application/json"
  result: libraryResponse

createBookTexResponse:
  call: http.post
  args:
    url: "[#DMAPPER_URL]:[#DMAPPER_PORT]/dmapper/bykMessageResponse"
    body:
      id: ${sessionId}
      lastMessage: ${libraryResponse.response.body}
  result: convertedResponse
  next: convertBykToOvon

createResponse:
  call: http.post
  args:
    url: "[#DMAPPER_URL]:[#DMAPPER_PORT]/dmapper/bykMessageResponse"
    body:
      id: ${sessionId}
      lastMessage: ${intentResponse.response.body.messages[0].text}
  result: convertedResponse

convertBykToOvon:
  call: http.post
  args:
    url: "[#DMAPPER_URL]:[#DMAPPER_PORT]/dmapper/bykToOvon-${protocolVersion}"
    body:
      bykResponse: ${convertedResponse.response.body.data}
      eventType: 'utterance'
      schemaVersion: ${schema.version}
      schemaUrl: ${schema.url}
      sender: ${request.ovon.sender.from}
      speakerId: ${speakerId}
  result: ovonResult
  next: returnSuccess

convertEmptyBykToOvon:
  call: http.post
  args:
    url: "[#DMAPPER_URL]:[#DMAPPER_PORT]/dmapper/bykToOvon-${protocolVersion}"
    body:
      bykResponse: "{'bykResponse': {'lastMessage':'', 'id': '0000'}"
      eventType: 'utterance'
      schemaVersion: ${schema.version}
      schemaUrl: ${schema.url}
      sender: ${request.ovon.sender.from}
      speakerId: ${speakerId}
  result: ovonResult
  next: returnSuccess

returnSuccess:
  wrapper: false
  return: ${ovonResult.response.body.data}
  next: end

returnBook:
  wrapper: false
  return: ${JSON.parse(libraryResponse.response.body).ovon.events[0].parameters.dialogEvent.features.text.tokens[0].value}
  next: end

returnError:
  return: "Sorry couldn't find proper event type, please make sure request is correct."
  next: end

returnNothing:
  wrapper: false
  return: ""
  status: 200
  next: end